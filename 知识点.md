### mustache语法

- 一个表达式
- 可以调用函数
- 三元运算符

### 基本语法

#### v-once

```shell
指定元素或者组件只渲染一次
当数据发生变化时，元素或者组件以及所有的子元素将视为静态内容并且跳过
该指令可以用于性能优化
```

#### v-html

```shell
展示的内容本事是html的，希望这个内容被vue解析出来，使用v-html
```

#### v-pre

```shell
跳过元素和它的子元素的编译过程，显示原始的mustache标签
```

#### v-bind绑定style

```shell
注意事项
	如果要绑定style，要加{}，如果不是data中的数据，键值对中的值要加引号
	属性命名使用驼峰命名法，如果要用-连接，要加引号
	例： fontSize  'font-size'
	 <div :style="{color: finalColor}">呵呵呵呵</div>
	 data(){
	 	return{
	 		finalColor: 'red',
	 	}
	 }
	 red加引号
```

#### v-if

```shell
v-if的渲染原理
	v-if的渲染是惰性的
	当条件是false时，判断的内容完全不会渲染或者被销毁掉
	当条件是true时，才会渲染条件中的内容
```

#### v-show和v-if的区别

```shell
如果需要频繁切换  v-show
不频繁切换  v-if
```

#### v-for

```shell
数组遍历
	参数   值，索引
	对象   值，键，索引
	数字   值，索引
```

#### computed

```shell
对多个data数据进行计算，三元运算符决定结果，数据进行转化显示使用computed
```

#### watch

```vue
默认情况下watch只会监听数据本身的改变(内部发生的改变是不能监听的)
例  
data() {
    return {
    	info:{name: 'kobe', age: 18}
    }
  },
改变info的值是可以监听的，改变info.name的值是不能监听的
这是需要进行深度监听
watch:{
	info:{
		handler:function(newValue,oldValue){
			console.log(newValue,oldValue)
		},
		deep: true,
		immediate: true  # 进入页面就进行监听
	}
}
```

####　v-model

```shell
v-model的原理
v-bind绑定value的值
v-on绑定input事件监听到函数中，函数会获取新的值赋值到绑定的属性中
```

#### 组件化开发

```shell
app.component(组件名称,组件对象)
组件名称命名：
	1.分隔符连接
	2.驼峰命名法
注册局部组件
	const app = {
		template: "#",
		components:{
			组件名称，组件对象
		}，
		data(){
			.....
		}
	}
```

#### webpack

```shell
打包
	打开文件夹  webpack  生成dist文件夹 （全局）
局部配置webpack
	npm init -y   生成package.json
局部安装webpack
	npm install webpack webpack-cli -D
局部打包
	在package.json中
		"script":{
			"build":"webpack"
		}
    执行 npm run build 完成打包
打包默认路径
	当前文件夹下的src的index.js
	如果没有index.js需要新增webpack.config.js进行配置
```

##### css-loader

```shel
需要使用loader对css进行解析
loader可以对模块的源代码进行解析
安装css-loader
npm install css-loader -D
安装完后需要在 webpack.config.js 进行配置
```

##### style-loader

```shell
想要让样式生效，需要安装style-loader
 npm install style-loader -D
 需要在webpace.config.js中进行配置
 loader的执行顺序是从下向上的
 所以顺序应该是
 use: [
     // {loader: 'css-loader'}
     "style-loader",
     "css-loader"
       ]
```

##### less-loader

```shell
处理less文件
安装less-loader
npm install less-loader -D
安装后需要在 webpack.config.js进行配置
```

##### file-loader

```shell
图片以src属性引用时
图片应该像模块一样导入使用

# 改变打包后的图片名
 {
     test:/\.(jpg|png|svg|gif)$/,
     use: {
     loader:"file-loader",
     options:{
     name: 'img/[name]_[hash:6].[ext]'
     }
     }
  }
```

#### ulr-loader

```shell
对比较小的图片进行base64编码 添加属性limit
{
    test:/\.(jpg|png|svg|gif)$/,
    use: {
    loader:"url-loader",
    options:{
    name: 'img/[name]_[hash:6].[ext]',
    limit: 100 * 1024
    }
    }
  }
```



#### postcss工具

```shell
postcss 是一个通过js转换样式的工具
工具可以帮助我们进行一些css的转换和适配，比如自动添加浏览器前缀，css样式的重置
但是需要借助postcss对应的插件
使用
npm install postcss postcss-cli -D
npm install autoprefixer -D
# 添加浏览器前缀
npx postcss --user autoprefixer -o demo.css(输出问价) test.css(已有文件)
```

#### 资源模块类型

asset module type(替代一些loader)  前提 webpack5

```shell
添加模块类型 替换loader
asset/resource  替换file-loader
asset/inline  替换url-loader
asset/source 替换raw-loader
asset 配置资源体积限制实现

## 使用
 {
     test:/\.(jpg|png|svg|gif)$/,
     type: "asset",
     generator:{
     filename:'img/[name]_[hash:6][ext]'
     },
     parser:{
     dataUrlCondition:{
     maxSize: 100 * 1024
     }
     }
   }
```

#### 打包字体文件

##### 方式1

file-loader

```shell]
 {
     test: /\.(eot|ttf|woff2?)$/,
     use:{
     loader:"file-loader",
     options:{
     name: "font/[name]_[hash:6].[ext]"
     }
     }
  }
```

##### 方式2

```shell
   {
       test: /\.(eot|ttf|woff2?)$/,
       type: 'asset/resource',
       generator: {
       filename:"font/[name]_[hash:6][ext]"
       }
    }
```

#### Plugin

##### cleanwebpackplugin

```shell
每次修改一些配置，重新打包时，都需要手动删除dist文件夹
首先导入
const { CleanWebpackPlugin } = require("clean-webpack-plugin")
然后引用
 plugins:[
 	new CleanWebpackPlugin()
 ]
```

##### htmlwebpackplugin

```shell
根目录下，最终打包dist文件夹没有index.html
在部署时，必须要有对应的入口文件index.html
```



