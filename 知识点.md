### mustache语法

- 一个表达式
- 可以调用函数
- 三元运算符

### 基本语法

#### v-once

```shell
指定元素或者组件只渲染一次
当数据发生变化时，元素或者组件以及所有的子元素将视为静态内容并且跳过
该指令可以用于性能优化
```

#### v-html

```shell
展示的内容本事是html的，希望这个内容被vue解析出来，使用v-html
```

#### v-pre

```shell
跳过元素和它的子元素的编译过程，显示原始的mustache标签
```

#### v-bind绑定style

```shell
注意事项
	如果要绑定style，要加{}，如果不是data中的数据，键值对中的值要加引号
	属性命名使用驼峰命名法，如果要用-连接，要加引号
	例： fontSize  'font-size'
	 <div :style="{color: finalColor}">呵呵呵呵</div>
	 data(){
	 	return{
	 		finalColor: 'red',
	 	}
	 }
	 red加引号
```

#### v-if

```shell
v-if的渲染原理
	v-if的渲染是惰性的
	当条件是false时，判断的内容完全不会渲染或者被销毁掉
	当条件是true时，才会渲染条件中的内容
```

#### v-show和v-if的区别

```shell
如果需要频繁切换  v-show
不频繁切换  v-if
```

#### v-for

```shell
数组遍历
	参数   值，索引
	对象   值，键，索引
	数字   值，索引
```

#### computed

```shell
对多个data数据进行计算，三元运算符决定结果，数据进行转化显示使用computed
```

#### watch

```vue
默认情况下watch只会监听数据本身的改变(内部发生的改变是不能监听的)
例  
data() {
    return {
    	info:{name: 'kobe', age: 18}
    }
  },
改变info的值是可以监听的，改变info.name的值是不能监听的
这是需要进行深度监听
watch:{
	info:{
		handler:function(newValue,oldValue){
			console.log(newValue,oldValue)
		},
		deep: true,
		immediate: true  # 进入页面就进行监听
	}
}
```

####　v-model

```shell
v-model的原理
v-bind绑定value的值
v-on绑定input事件监听到函数中，函数会获取新的值赋值到绑定的属性中
```

#### 组件化开发

```shell
app.component(组件名称,组件对象)
组件名称命名：
	1.分隔符连接
	2.驼峰命名法
注册局部组件
	const app = {
		template: "#",
		components:{
			组件名称，组件对象
		}，
		data(){
			.....
		}
	}
```

#### webpack

```shell
打包
	打开文件夹  webpack  生成dist文件夹 （全局）
局部配置webpack
	npm init -y   生成package.json
局部安装webpack
	npm install webpack webpack-cli -D
局部打包
	在package.json中
		"script":{
			"build":"webpack"
		}
    执行 npm run build 完成打包
打包默认路径
	当前文件夹下的src的index.js
	如果没有index.js需要新增webpack.config.js进行配置
```

##### css-loader

```shel
需要使用loader对css进行解析
loader可以对模块的源代码进行解析
安装css-loader
npm install css-loader -D
安装完后需要在 webpack.config.js 进行配置
```

##### style-loader

```shell
想要让样式生效，需要安装style-loader
 npm install style-loader -D
 需要在webpace.config.js中进行配置
 loader的执行顺序是从下向上的
 所以顺序应该是
 use: [
     // {loader: 'css-loader'}
     "style-loader",
     "css-loader"
       ]
```

##### less-loader

```shell
处理less文件
安装less-loader
npm install less-loader -D
安装后需要在 webpack.config.js进行配置
```

##### file-loader

```shell
图片以src属性引用时
图片应该像模块一样导入使用

# 改变打包后的图片名
 {
     test:/\.(jpg|png|svg|gif)$/,
     use: {
     loader:"file-loader",
     options:{
     name: 'img/[name]_[hash:6].[ext]'
     }
     }
  }
```

#### ulr-loader

```shell
对比较小的图片进行base64编码 添加属性limit
{
    test:/\.(jpg|png|svg|gif)$/,
    use: {
    loader:"url-loader",
    options:{
    name: 'img/[name]_[hash:6].[ext]',
    limit: 100 * 1024
    }
    }
  }
```



#### postcss工具

```shell
postcss 是一个通过js转换样式的工具
工具可以帮助我们进行一些css的转换和适配，比如自动添加浏览器前缀，css样式的重置
但是需要借助postcss对应的插件
使用
npm install postcss postcss-cli -D
npm install autoprefixer -D
# 添加浏览器前缀
npx postcss --user autoprefixer -o demo.css(输出问价) test.css(已有文件)
```

#### 资源模块类型

asset module type(替代一些loader)  前提 webpack5

```shell
添加模块类型 替换loader
asset/resource  替换file-loader
asset/inline  替换url-loader
asset/source 替换raw-loader
asset 配置资源体积限制实现

## 使用
 {
     test:/\.(jpg|png|svg|gif)$/,
     type: "asset",
     generator:{
     filename:'img/[name]_[hash:6][ext]'
     },
     parser:{
     dataUrlCondition:{
     maxSize: 100 * 1024
     }
     }
   }
```

#### 打包字体文件

##### 方式1

file-loader

```shell]
 {
     test: /\.(eot|ttf|woff2?)$/,
     use:{
     loader:"file-loader",
     options:{
     name: "font/[name]_[hash:6].[ext]"
     }
     }
  }
```

##### 方式2

```shell
   {
       test: /\.(eot|ttf|woff2?)$/,
       type: 'asset/resource',
       generator: {
       filename:"font/[name]_[hash:6][ext]"
       }
    }
```

#### Plugin

##### cleanwebpackplugin

```shell
每次修改一些配置，重新打包时，都需要手动删除dist文件夹
首先导入
const { CleanWebpackPlugin } = require("clean-webpack-plugin")
然后引用
 plugins:[
 	new CleanWebpackPlugin()
 ]
```

##### htmlwebpackplugin

```shell
根目录下，最终打包dist文件夹没有index.html
在部署时，必须要有对应的入口文件index.html
```

#### DefinePlugin

```shell
 # 取消警告配置
 new DefinePlugin({
      BASE_URL: "'./'",
      __VUE_OPTIONS_API__: true,
      __VUE_PROD_DEVTOOLS__: false
 }),
```



#### babel

```shell
代码转化  es6-> es5
安装：
	npm install @babel/core @babel/cli -D
在进行转化的时候，比如需要转换箭头函数，那么我们使用箭头函数转换相关的插件
npm install @babel/plugin-transform-arrow-functions -D
对const进行转换
npm install @babel/plugin-transform-block-scoping -D

集成好的插件
npm install @babel/preset-env -D

开始转换
npx babel demo.js --out-file test.js --presets=@babel/preset-env

结合webpack使用
安装 npm install babel-loader -D/ npm install @babel/core -D

 {
     test:/\.js$/,
     use:{
     loader:'babel-loader',
     options:{
     presets:[
     "@babel/preset-env"
     ]
     }
     }
  }
  
  将配置文件进行抽离
  babel提供了两种配置文件的编写
  babel.config.json(或者.js,.cjs,.mjs)  (更推荐)
  .babelrc.json(或者.babelrc, .js,.cjs)
  
```

#### 打包vue

```shell
安装
npm install vue@next
安装loader
npm install vue-loader@next -D
同时对webpack.config.js 进行配置
安装解析vue包
npm install @vue/compiler-sfc -D
```

#### webpack watch

```shell
webpack提供了watch模式
	只要文件有一个发生更新，代码就重新编译
如何开启
	方式1：在导出的配置中 添加watch：true
	方式2：在启动webpack的命令中，添加--watch标识
```

#### webpack-dev-server

```shell
在不使用vscode live-server的情况下，并且具备实时重新加载的功能
安装
	npm install webpack-dev-server -D
配置脚本
"scripts": {
    "build": "webpack",
    "serve": "webpack serve"
  },
  
webpack在编译后不会写入到任何输出文件，将bundle文件保存到内存中

```

#### 模块热替换

```shell
HMR 为模块热替换
应用程序在运行过程中，替换，添加，删除 无需重新刷新整个页面

不重新加载整个页面，可以保留某些状态不丢失
更新需要变化的内容
修改css js 会立即在浏览器更新

webpack-dev-server 已经支持HRM 只需要配置

```

#### webpack配置HMR

```shell
 target: "web"
 devServer:{
        hot: true,
        host: "0.0.0.0",
        port: 7777,
        open: true
 },
```

#### resolve

```shell
resolve:{
	extensions:['.js','.json','.vue','.ts']
	alias:{
		"@": path.resolve(__dirname,"./src")
	}
}
```

#### 开发生产分离

```shell
npm install webpack-merge -D
```

#### vue-cli

```shell
命令行安装
	npm install @vue/cli -g
创建项目
	vue create 项目名称
```

#### vite

```shell
npm install vite -D
启动：
	在局部环境下
	npx vite
加载less文件
	安装less  npm install less -D
配置浏览器头
	安装postcss postcss-preset-env
配置postcss.config.js
module.exports = {
    plugins:[
        require("postcss-preset-env")
    ]
}

vite对vue的支持
安装插件
npm install  @vitejs/plugin-vue
插件依赖另一个插件
npm install @vue/compiler-sfc -D
进行配置
vite.config.js

const vue = require("@vitejs/plugin-vue")

module.exports = {
    plugins:[
        vue()
    ]
}

打包  npx vite build
预览  npx vite preview

启动配置  package.json
  "scripts": {
    "serve":"vite",
    "build":"vite build",
    "preview":"vite preview"
  },
```

#### vitecli

```shell
安装 vitecli
npm install @vitejs/create-app -g
创建项目
create-app 项目名称
npm install
```

#### vue3

```shell
插件
vetur
vue3 snippets
```

##### 组件通信

```shell
父传子
	通过props属性
子传父
	通过$emit触发事件


父传子
props 绑定在子组件
        父组件传对象值时  可以使用 v-bind="对象名称"
        props 对象传法
        例：
            content :{
                type: String,
                required : true (必传),
                default: "123" (默认)
            }
        多个类型：
            propB: [String,Number]
        对象类型，默认值要是函数
            prope:{
                type: Object,
                default(){
                    return:{name:"why"}
                }
            }
        驼峰命名传值的时候尽量转换成-连接
非prop的attribute
	常见的包括class，style，id
	1.当组件有单个跟节点时
		非prop的attribute自动添加到跟节点的attribute
    2. 禁用attribute
    	将attribute应用到根元素外的其他元素
    	通过$attrs来访问非props的attribute
    	export default{
    		inheritAttrs: false
    		props:{
    			....
    		}
    	}
    	子组件
    	<div>
        	<h2 :class="$attrs.class"></h2>
        </div>
	3.多个跟节点时（多个子组件公用一个跟）
		手动的绑定到某一个属性上
 
 子传父
 	1.在子组件定义好某些情况下触发的事件名称
 	2.在父组件以v-on的方式监听事件名称,绑定到对应的方法上
 	3.最后，在子组件发生某个事件的时候，根据事件名称触发对应的事件
```

##### provide和inject

```shell
非父子组件间共享数据
比如一些嵌套非常深的组件
父组件有一个provide选项提供数据
子组件有一个inject选项开始使用这些数据

provide使用data中的数据时 provide需要是一个函数
```

##### 事件总线  mitt库

```shell
安装 npm install mitt
```

##### 插槽slot

```shell
插槽使用抽取共性，预留不同
共同的元素，内容在组件内封装
将不同的元素使用slot进行占位,让外部决定显示什么样的元素
```

